package  oneDCellSpace;

import java.lang.*;
import java.awt.*;
import java.io.*;
import java.util.*;
import genDevs.modeling.*;
import genDevs.plots.*;
import genDevs.simulation.*;
import GenCol.*;
import statistics.*;
import simView.*;
import pulseExpFrames.*;
import genDevs.simulation.special.*;
import quantization.*;

class diffuseRandCell extends diffuse2ndOrdCell implements oneDCell{

protected double ps;

public static double ts,maxder;
// ts/ps= q/deriv  so ps = deriv*(ts/q)
//1 = maxder*(ts/q) so ts/q = 1/maxder
//so ps = deriv/maxder

public static int numCells = 10;
public  static double baseSpeed = 1;


public diffuseRandCell(){
this(0);
}

public diffuseRandCell(int id){
super(id);
}


public void initialize(){
r = new rand(id);
myPos = leftPos = rightPos = nextPos = quantum;
myPos = id*height/numCells;
clock = 0.0;
speed = baseSpeed;
numTransitions  = 0;
holdIn("start",0);
}


public double avgNeighPos(){
if (id == 0)leftPos = myPos;
else if (id == numCells-1) rightPos = myPos;
return (leftPos + rightPos)/2;
}

public double spatialDeriv(){
return 2*(avgNeighPos() - myPos)/deltaxsq;
}

public double deriv(){
return speed*spatialDeriv();
}


public void computePandT(){

   if (Math.abs(deriv())<=0){
   sigma = INFINITY;
   ps = 0;
   }
   else{
   //sigma = ts;
   sigma = r.expon(ts);//works even with uncoordinated time step
  // normal(ts,ts);
   //sigma = sigma <0?-sigma:sigma;
   ps = Math.abs(deriv())/maxder;
   }
    phase = ""+myPos;
}





public void  deltext(double e,message   x)
{

 Continue(e);

if (somethingOnPort(x,"inLeft"))
leftPos = getRealValueOnPort(x,"inLeft");

if (somethingOnPort(x,"inRight"))
rightPos = getRealValueOnPort(x,"inRight");

  computePandT();

}


public void  deltint( ){

if (phaseIs("success"))
computePandT();
else
if (r.uniform(1)<ps){
myPos += deriv()>0?quantum:-quantum;
numTransitions++;
holdIn("success",0);
   }

}


public void deltcon(double e,message x){
    deltext(e,x);
}

public message    out( )
{
message   m = new message();
if (phaseIs("start")|| phaseIs("success")){
m.add(makeContent("outPos", new doubleEnt(myPos)));
m.add(makeContent("outDraw",  new DrawCellEntity("drawCellToScale",
       drawPos, myPos)));
m.add(makeContent("outNum",  new DrawCellEntity("drawCellToScale",
       drawPos, numTransitions)));
}
return m;
}

public String getTooltipText(){
   return
   super.getTooltipText()
   +"\n"+" maxder: "+ maxder
      +"\n"+" deriv: "+ deriv()
    +"\n"+" ps: "+ ps;
  }
}


public class diffuseRandCellSpace extends oneDimCellSpace{

public diffuseRandCellSpace(){
this(50);
}

public diffuseRandCellSpace(int numCells){
super("diffuseRandCellSpace "+numCells);
addInport("outPair");

diffuseRandCell.numCells = numCells;
diffuseRandCell.deltaxsq = (diffuseRandCell.length/numCells)*(diffuseRandCell.length/numCells);
diffuseRandCell.quantum = .05;//.11;//2;//.11;//.001;//.0005;//.001;//1;//.1;// .005;
diffuseRandCell.maxder =  numCells*diffuseRandCell.baseSpeed*diffuseRandCell.height/(
         diffuseRandCell.length*diffuseRandCell.length);

diffuseRandCell.ts = diffuseRandCell.quantum/diffuseRandCell.maxder;

System.out.println("quantum implied by Courant " +.5*diffuseRandCell.height/numCells);

for (int i = 0;i<numCells;i++)
  addCell(i,new diffuseRandCell(i));

//
hideAll();  //hides only components so far


doNeighborCoupling(1,"outPos","inLeft");//to right on inLeft
doNeighborCoupling(-1,"outPos","inRight");//to left on inRight


totalTransitions t = new totalTransitions();
add(t);
coupleAllTo("outNum",t,"in");
/*
activityTrans m = new activityTrans("minmaxIndiv", numCells);
add(m);
coupleAllTo("outPair",m,"inPair");
*/
addPlots((double)3*diffuseRandCell.height,(int)(300/diffuseRandCell.quantum),100.,.01); //at end so that will not be coupled in
}


public static void main(String args[]){


int numCells = 50;//1000
int numiter = 1000000;//100;//2*numCells;
int base = 6;//100;//5;// 2;//50;

//coordinator c = new coordinator(new diffuseRandCellSpace(numCells ));

//oneDCoordV4 c = new oneDCoordV4(new diffuseRandCellSpace(numCells),base,numCells);
//
oneDCoord c = new oneDCoord(new diffuseRandCellSpace(numCells),base,numCells);
c.initialize();

System.out.println("Simulating "+c.getCoupled().getName()+" base "+base);
c.initialize();

long initTime,termTime;

initTime = System.currentTimeMillis();
System.out.println("Start time: "+initTime);

c.simulate(numiter);

termTime = System.currentTimeMillis();
System.out.println("End time "+termTime);
System.out.println("Execution Time in secs. for "+ numiter +" iterations: "
                    +((termTime-initTime)/1000.0));
System.exit(0);

}

    /**
     * Automatically generated by the SimView program.
     * Do not edit this manually, as such changes will get overwritten.
     */
    public void layoutForSimView()
    {
        preferredSize = new Dimension(900, 1300);
        ((ViewableComponent)withName("totalTransitions")).setPreferredLocation(new Point(-24, 8));
    }
}

